"""
Loads passwords and other attributes from HTML reports generated by Passware.
This allows for the easy sharing of a file md5 and its corresponding password.

Formatted with Black

"""

# Import functions
import argparse
import json
import os
import pandas as pd
from pprint import pprint
import re
import sys

# ------------ Setup ------------------------------------------------------------------

debug = False

__author__ = "facelessg00n"
__description__ = "Extracts passwords and other attributes from passware reports. Script will look for file called 'report.html' in the current working directory if no input is specified."

### Regex to extract JSON from the end of the HTML file.
JSON_reg = re.compile(
    r"(?s)(?<=(\<\!-- (raw reports and clues in JSON format\n))).*(}\n--\>)"
)
# Regex to extract reports portion from JSON
PWD_reg = re.compile(r"(?s)(?<=(Reports:\n)).*(?=(\n--\>))")

# ------------- Classes ---------------------------------------------------------------

# Initiate Class to hold password objects


class PasswordObject:
    def __init__(self, pWord):

        # Success Indicator
        self.success = pWord["passwordsFound"]

        # Name of cracked File
        self.fileName = pWord["report"]["protectionContainers"][0]["source"][0][
            "filename"
        ]
        # MD5 of Cracked file
        self.fileHash = pWord["report"]["protectionContainers"][0]["source"][0]["md5"]

        # Recovered Password
        try:
            self.recoveredPassword = pWord["report"]["protectionContainers"][0][
                "protectionItems"
            ][0]["password"]["value"]
        except:
            self.recoveredPassword = None
            pass

        #  Format of Protector i.e Rar3.x
        self.protectorFormat = pWord["report"]["protectionContainers"][0]["protection"][
            "format"
        ]["id"].split(":")[1]

        # Encryption type of protector
        try:
            self.encType = pWord["report"]["protectionContainers"][0]["protection"][
                "flags"
            ][2]["id"].split(":")[1]
        except:
            self.encType = None

    # Returns values as a dictionary
    def as_dict(self):
        return {
            "Success": self.success,
            "Protector_format": self.protectorFormat,
            "Encryption type": self.encType,
            "File_Name": self.fileName,
            "Password": self.recoveredPassword,
            "md5": self.fileHash,
        }


# ----- Functions live here -----------------------------------------------------------

#  Load data
def dataLoad(input_file):
    f = open(input_file, "r")
    input_data = f.read()
    f.close()
    if debug:
        print(input_data)
    json_data = re.search(JSON_reg, input_data)
    passdata_json = re.search(PWD_reg, json_data[0])
    data = json.loads(passdata_json[0])
    if debug:
        # print(passdata_json[0])
        with open("debug_data.json", "w") as f:
            f.write(str(passdata_json[0]))

    return data


# Iterate over JSON data and build up class objects
def processJSON(input_file):
    inputObjectList = dataLoad(input_file)
    objectList = []
    successList = []
    for inputObject in inputObjectList.keys():
        pwdObject = PasswordObject(inputObjectList[inputObject])
        objectList.append(pwdObject)

    # Extract successful password cracks.
    for x in objectList:
        successList.append(x.recoveredPassword)
    dedupList = list(dict.fromkeys(successList))

    # Remove 'None' values
    dedupList = list(filter(None, dedupList))

    if debug:
        for x in objectList:
            pprint(x.__dict__)
            print(successList)
            print(dedupList)

    # Make a dataframe, just because. Can fix later with csv
    df = pd.DataFrame([x.as_dict() for x in objectList])
    print(df)
    df.to_csv("cracked.csv")


# input_file = "report.html"
# processJSON(input_file)

# ------- Argument Parser -------------------------------------------------------------

parser = argparse.ArgumentParser(
    description=__description__, epilog="Developed by {}".format(__author__)
)

parser.add_argument(
    "-f",
    "--input_file",
    help="\nFilename or path for input file\n",
    default="report.html",
)
args = parser.parse_args()
file_path = args.input_file

""" if len(sys.argv) == 1:
    parser.print_help()
    sys.exit(1)
 """

# Check if the input file exists.
if not os.path.exists(args.input_file):
    print(
        "ERROR: Input file; '{}' does not exist or is not a file".format(
            args.input_file
        )
    )
    sys.exit(1)

if file_path:
    processJSON(file_path)
if not file_path:
    print("No file specified, looking for report in the default directory")
    processJSON("report.html")
